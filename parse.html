<head>
<style>
textarea {
  width: 100%;
  min-height: 50px;
  padding: 10px;
  resize: none; /* Disable the manual resize handle */
  overflow: hidden; /* Hide the scrollbar */
  box-sizing: border-box;
}
</style>
<script>

class ReadBitStream {
    constructor(uint8Array) {
        this.bytes = uint8Array;
        this.byteIndex = 0;
        this.bitIndex = 0; // 0..7, MSB first
    }
    read(bits) {
        let value = 0;
        for (let i = 0; i < bits; i++) {
            if (this.byteIndex >= this.bytes.length) {
                throw new Error("End of stream reached");
            }
            const byte = this.bytes[this.byteIndex];
            const bit = (byte >> (7 - this.bitIndex)) & 1;
            value = (value << 1) | bit;

            this.bitIndex++;
            if (this.bitIndex === 8) {
                this.bitIndex = 0;
                this.byteIndex++;
            }
        }
        return value;
    }
};

// Table C.1 — Application #5 syntax structure
let parseApplicationInfo = function(stream, syntax) {
    syntax.application_version = stream.read(3);
    syntax.minimum_application_version = stream.read(3);
    syntax.reserved_zero_c1 = stream.read(2);
    parseColorVolumeTransform(stream, syntax);
}


// Table C.2 — Color volume transform syntax structure
let parseColorVolumeTransform = function(stream, syntax) {
    syntax.has_custom_hdr_reference_white_flag = stream.read(1);
    syntax.has_adaptive_tone_map_flag = stream.read(1);
    syntax.reserved_zero_c2 = stream.read(6);

    if (syntax.has_custom_hdr_reference_white_flag === 1) {
        syntax.hdr_reference_white = stream.read(16);
    }
    if (syntax.has_adaptive_tone_map_flag === 1) {
        parseAdaptiveToneMap(stream, syntax);
    }
}

// Table C.3 — Headroom-adaptive tone map structure syntax
let parseAdaptiveToneMap = function(stream, syntax) {
    syntax.baseline_hdr_headroom = stream.read(16);
    syntax.use_reference_white_tone_mapping_flag = stream.read(1);

    if (syntax.use_reference_white_tone_mapping_flag === 0) {
        syntax.num_alternate_images = stream.read(3);
        syntax.gain_application_space_chromaticities_mode = stream.read(2);
        syntax.has_common_component_mix_params_flag = stream.read(1);
        syntax.has_common_curve_params_flag = stream.read(1);
        
        if (syntax.gain_application_space_chromaticities_mode === 3) {
            syntax.gain_application_space_chromaticities = [];
            for (let r = 0; r < 8; r++) {
                syntax.gain_application_space_chromaticities[r] = stream.read(16);
            }
        }

        if (syntax.num_alternate_images > 0) {
            syntax.alternate_hdr_headrooms = [];
            syntax.component_mixing_type = [];
            syntax.has_component_mixing_coefficient_flag = [];
            syntax.component_mixing_coefficients = [];
            syntax.gain_curve_num_control_points_minus_1 = [];
            syntax.gain_curve_use_pchip_slope_flag = [];
            syntax.gain_curve_control_points_x = [];
            syntax.gain_curve_control_points_y = [];
            syntax.gain_curve_control_points_theta = [];
            syntax.reserved_zero_c4 = []
            syntax.reserved_zero_c5 = []

            const num_alternate_images_loop_limit = Math.min(syntax.num_alternate_images, 4);
            for (let a = 0; a < num_alternate_images_loop_limit; a++) {
                syntax.alternate_hdr_headrooms[a] = stream.read(16);
                parseComponentMixing(stream, syntax, a);
                parseGainCurve(stream, syntax, a);
            }
        }
    } else {
        syntax.reserved_zero_c3 = stream.read(7);
    }
}

// Table C.4 — Component mixing function structure syntax
let parseComponentMixing = function(stream, syntax, a) {
  if (a === 0 || syntax.has_common_component_mix_params_flag === 0) {
    syntax.component_mixing_type[a] = stream.read(2);

    if (syntax.component_mixing_type[a] !== 3) {
      syntax.has_component_mixing_coefficient_flag[a] = null;
      syntax.component_mixing_coefficients[a] = null;
      syntax.reserved_zero_c4[a] = stream.read(6);
    } else {
      syntax.has_component_mixing_coefficient_flag[a] = [];
      syntax.component_mixing_coefficients[a] = [];
      syntax.reserved_zero_c4[a] = null;
      for (let k = 0; k < 6; k++) {
        syntax.has_component_mixing_coefficient_flag[a][k] = stream.read(1);
      }
      for (let k = 0; k < 6; k++) {
        if (syntax.has_component_mixing_coefficient_flag[a][k] === 1) {
          syntax.component_mixing_coefficients[a][k] = stream.read(16); 
        } else {
          syntax.component_mixing_coefficients[a][k] = 0;
        }
      }
    }
  } else {
    syntax.component_mixing_coefficients[a] = [];
    for (let k = 0; k < 6; k++) {
      syntax.component_mixing_coefficients[a][k] = syntax.component_mixing_coefficients[0][k];
    }
  }
}

// Table C.5 — Gain curve structure syntax
let parseGainCurve = function(stream, syntax, a) {
    if (a === 0 || syntax.has_common_curve_params_flag === 0) {
        syntax.gain_curve_num_control_points_minus_1[a] = stream.read(5);
        syntax.gain_curve_use_pchip_slope_flag[a] = stream.read(1);
        syntax.reserved_zero_c5[a] = stream.read(2);

        syntax.gain_curve_control_points_x[a] = [];
        for (let c = 0; c < syntax.gain_curve_num_control_points_minus_1[a] + 1; c++) {
            syntax.gain_curve_control_points_x[a][c] = stream.read(16);
        }
    } else {
        syntax.reserved_zero_c5[a] = null;
        syntax.gain_curve_num_control_points_minus_1[a] = syntax.gain_curve_num_control_points_minus_1[0];
        syntax.gain_curve_use_pchip_slope_flag[a] = syntax.gain_curve_use_pchip_slope_flag[0];
        syntax.gain_curve_control_points_x[a] = syntax.gain_curve_control_points_x[0];
    }
    syntax.gain_curve_control_points_y[a] = [];
    for (let c = 0; c < syntax.gain_curve_num_control_points_minus_1[a] + 1; c++) {
        syntax.gain_curve_control_points_y[a][c] = stream.read(16);
    }
    if (syntax.gain_curve_use_pchip_slope_flag[a] === 0) {
        syntax.gain_curve_control_points_theta[a] = [];
        for (let c = 0; c < syntax.gain_curve_num_control_points_minus_1[a] + 1; c++) {
            syntax.gain_curve_control_points_theta[a][c] = stream.read(16);
        }
    }
}
 
// From Gemini:
function compactJson(data, indent = 2) {
  // Helper to determine if an array only contains primitives
  const isFlatArray = (arr) => {
    return arr.every(item => 
      typeof item !== 'object' || item === null
    );
  };

  function format(curr, level, flatten = false) {
    const currentIndent = ' '.repeat(level * indent);
    const nextIndent = ' '.repeat((level + 1) * indent);

    if (Array.isArray(curr)) {
      // Case 1: Array of primitives -> Single line: [1, 2, 3]
      if (isFlatArray(curr)) {
        // JSON.stringify gives [1,2,3], we add spaces after commas for readability
        return JSON.stringify(curr).replace(/,/g, ', ');
      }
      
      // Case 2: Array of Objects/Arrays -> Standard multiline formatting
      const items = curr.map(v => format(v, level + 1, flatten));
      return `[\n${nextIndent}${items.join(`,\n${nextIndent}`)}\n${currentIndent}]`;
    }
    
    if (typeof curr === 'object' && curr !== null) {
      const keys = Object.keys(curr);
      if (keys.length === 0) return '{}';
      
      const items = keys.map(key => {
        let nextFlatten = false;
        nextFlatten |= key === "component_mixing";
        nextFlatten |= key === "control_points";
        nextFlatten |= key === "red";
        nextFlatten |= key === "green";
        nextFlatten |= key === "blue";
        nextFlatten |= key === "white";
        const val = format(curr[key], level + 1, nextFlatten);
        // Ensure keys are quoted strings
        return `"${key}": ${val}`;
      });
      if (flatten) {
        return `{ ${items.join(`, `)} }`;
      } else {
        return `{\n${nextIndent}${items.join(`,\n${nextIndent}`)}\n${currentIndent}}`;
      }
    }

    // Primitives (strings, numbers, booleans, null)
    return JSON.stringify(curr);
  }

  return format(data, 0);
}

let getRec709Primaries = function() {
  return {
    red: { x: 0.64, y: 0.33 },
    green: { x: 0.3, y: 0.6 },
    blue: { x: 0.15, y: 0.06 },
    white: { x: 0.3127, y: 0.329 },
  };
}

let getP3Primaries = function() {
  return {
    red: { x: 0.68, y: 0.32 },
    green: { x: 0.265, y: 0.69 },
    blue: { x: 0.15, y: 0.06 },
    white: { x: 0.3127, y: 0.329 },
  };
}

let getRec2020Primaries = function() {
  return {
    red: { x: 0.708, y: 0.292 },
    green: { x: 0.170, y: 0.797},
    blue: { x: 0.131, y: 0.046 },
    white: { x: 0.3127, y: 0.329 },
  };
}

let populateWithPCHIP = function(control_points) {
  for (let i = 0; i < control_points.length; ++i) {
    control_points[i].m = "TODO-PCHIP";
  }
}

let populateWithRWTMO = function(hatm) {
  hatm.gain_application_space_primaries = getRec2020Primaries();
  hatm.alternate_images = "TODO-RWTMO";
}

let syntaxToMetadata = function(syntax, metadata) {
  let uint16_to_float = function(v, clamp_min, clamp_max, offset, scale) {
    if (v < clamp_min) v = clamp_min;
    if (v > clamp_max) v = clamp_max;
    return (v - offset) / scale;
  }

  if (syntax.has_custom_hdr_reference_white_flag === 1) {
    metadata.hdr_reference_white = uint16_to_float(syntax.hdr_reference_white, 1, 50000, 0, 5.0);
  } else {
    metadata.hdr_reference_white = 1000.0;
  }

  if (syntax.has_adaptive_tone_map_flag === 1) {
    let hatm = {};
    hatm.baseline_hdr_headroom = uint16_to_float(syntax.baseline_hdr_headroom, 0, 60000, 0, 10000.0);

    if (syntax.use_reference_white_tone_mapping_flag === 0) {
      if (syntax.gain_application_space_chromaticities_mode === 0) {
        hatm.gain_application_space_primaries = getRec709Primaries();
      } else if (syntax.gain_application_space_chromaticities_mode === 1) {
        hatm.gain_application_space_primaries = getP3Primaries();
      } else if (syntax.gain_application_space_chromaticities_mode === 2) {
        hatm.gain_application_space_primaries = getRec2020Primaries();
      } else if (syntax.gain_application_space_chromaticities_mode === 3) {
        hatm.gain_application_space_primaries = {
          red: {
            x: uint16_to_float(syntax.gain_application_space_chromaticities[0], 0, 50000, 0, 50000.0),
            y: uint16_to_float(syntax.gain_application_space_chromaticities[1], 0, 50000, 0, 50000.0),
          },
          green: {
            x: uint16_to_float(syntax.gain_application_space_chromaticities[2], 0, 50000, 0, 50000.0),
            y: uint16_to_float(syntax.gain_application_space_chromaticities[3], 0, 50000, 0, 50000.0),
          },
          blue: {
            x: uint16_to_float(syntax.gain_application_space_chromaticities[4], 0, 50000, 0, 50000.0),
            y: uint16_to_float(syntax.gain_application_space_chromaticities[5], 0, 50000, 0, 50000.0),
          },
          white: {
            x: uint16_to_float(syntax.gain_application_space_chromaticities[6], 0, 50000, 0, 50000.0),
            y: uint16_to_float(syntax.gain_application_space_chromaticities[7], 0, 50000, 0, 50000.0),
          },
        };
      }

      if (syntax.num_alternate_images > 0) {
        hatm.alternate_images = [];
        const num_alternate_images_loop_limit = Math.min(syntax.num_alternate_images, 4);
        for (let a = 0; a < num_alternate_images_loop_limit; a++) {
          let alt = {};
          alt.hdr_headroom = uint16_to_float(syntax.alternate_hdr_headrooms[a], 0, 60000, 0, 10000.0);

          if (syntax.component_mixing_type[a] === 3) {
            alt.component_mixing = {
              red: uint16_to_float(syntax.component_mixing_coefficients[a][0], 0, 50000, 0, 50000.0),
              green: uint16_to_float(syntax.component_mixing_coefficients[a][1], 0, 50000, 0, 50000.0),
              blue: uint16_to_float(syntax.component_mixing_coefficients[a][2], 0, 50000, 0, 50000.0),
              max: uint16_to_float(syntax.component_mixing_coefficients[a][3], 0, 50000, 0, 50000.0),
              min: uint16_to_float(syntax.component_mixing_coefficients[a][4], 0, 50000, 0, 50000.0),
              component: uint16_to_float(syntax.component_mixing_coefficients[a][5], 0, 50000, 0, 50000.0),
            };
          }

          alt.gain_curve = {
            control_points: []
          };
          const sign = hatm.baseline_hdr_headroom < alt.hdr_headroom ? 1.0 : -1.0;
          for (let c = 0; c < syntax.gain_curve_num_control_points_minus_1[a] + 1; c++) {
            let cp = {
              x: uint16_to_float(syntax.gain_curve_control_points_x[a][c], 0, 64000, 0, 1000.0),
              y: sign * uint16_to_float(syntax.gain_curve_control_points_y[a][c], 0, 60000, 0, 10000.0),
            };
            if (syntax.gain_curve_use_pchip_slope_flag[a] === 0) {
              const theta = uint16_to_float(syntax.gain_curve_control_points_theta[a][c], 1, 35999, 18000, 36000.0 / Math.PI);
              cp.m = Math.tan(theta);
            }
            alt.gain_curve.control_points.push(cp);
          }
          if (syntax.gain_curve_use_pchip_slope_flag[a] === 1) {
            populateWithPCHIP(alt.gain_curve.control_points);
          }
          hatm.alternate_images.push(alt);
        }
      }
    } else {
      populateWithRWTMO(hatm);
    }
    metadata.adaptive_tone_map = hatm;
  }
  return metadata;
}

const kEditingColor = "white";
const kErrorColor = "rgb(255, 200, 200)";
const kPassColor = "rgb(200, 255, 200)";
const kOutdatedColor = "rgb(200, 200, 200)";

let onBinaryChanged = function() {
  Binary.style.height = "auto";
  Binary.style.height = (Binary.scrollHeight) + "px";
  Binary.style.backgroundColor = kEditingColor;
  Syntax.style.backgroundColor = kOutdatedColor;
  Semantics.style.backgroundColor = kOutdatedColor;

  // Parse the syntax
  const list = Binary.value.split(',').map(item => Number(item.trim()));
  const buffer = new Uint8Array(list);
  let syntax = {};
  let metadata= {};
  try {
    parseApplicationInfo(new ReadBitStream(buffer), syntax);
    Syntax.style.backgroundColor = kPassColor;

    // Parse semantics
    try {
      Semantics.textContent = syntaxToMetadata(syntax, metadata);
      Semantics.style.backgroundColor = kPassColor;
    } catch (e) {
      Semantics.textContent = 'error';
      Semantics.style.backgroundColor = kErrorColor;
    }
  } catch (e) {
    Syntax.style.backgroundColor = kErrorColor;
    Semantics.style.backgroundColor = kErrorColor;
  }
  Syntax.textContent = compactJson(syntax);
  Semantics.textContent = compactJson(metadata);

};

let main = function() {
  onBinaryChanged();
}

</script>
</head>
<body onload="main();">
<h2>Binary</h2>
<p>Comma separated list of hex values, as of the form output by <code>xxd -i</code>.</p>
<p>
<textarea id="Binary" rows=10, cols=120 oninput="onBinaryChanged();">
  0x00, 0xc0, 0x07, 0xd0, 0x4e, 0x20, 0x44, 0x00, 0x00, 0xc6, 0x92, 0x7c,
  0x30, 0xd4, 0x00, 0x00, 0x00, 0x27, 0x10, 0x46, 0x50, 0x27, 0x10, 0x00,
  0x18, 0x00, 0x00, 0x03, 0xe8, 0x07, 0xd0, 0x0b, 0xb8, 0x27, 0x10, 0x13,
  0x88, 0x0f, 0xa0, 0x0b, 0xb8, 0x46, 0x50, 0x4a, 0xc6, 0x4f, 0x26, 0x53,
  0x5c, 0x75, 0x30, 0x40, 0x08, 0x00, 0x00, 0x03, 0xe8, 0x27, 0x10, 0x13,
  0x88, 0x46, 0x50, 0x4a, 0xc6, 0x9c, 0x40, 0xf8, 0x3a, 0x98, 0x75, 0x30,
  0x13, 0x88, 0x18, 0x00, 0x00, 0x03, 0xe8, 0x07, 0xd0, 0x07, 0xd0, 0x27,
  0x10, 0x13, 0x88, 0x0f, 0xa0, 0x0f, 0xa0, 0x46, 0x50, 0x4a, 0xc6, 0x5b,
  0x11, 0x61, 0xa6,"
</textarea>
</p>
</input>
<h2>Syntax:</h2>
<pre id="Syntax"></pre>
<h2>Semantics:</h2>
<pre id="Semantics"></pre>
</body>
