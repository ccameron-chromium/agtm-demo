<head>
<style>
textarea {
  width: 100%;
  min-height: 50px;
  padding: 10px;
  resize: none; /* Disable the manual resize handle */
  overflow: hidden; /* Hide the scrollbar */
  box-sizing: border-box;
}
</style>

<script type="module">
// Import SmpteSt2094App5 into the global namespace
import * as SmpteSt2094App5 from "./smpte-st-2094-50.js";
window.SmpteSt2094App5 = SmpteSt2094App5;
</script>
<script>

// Gemini-generated function to make pretty JSON for an object.
function compactJson(data, indent = 2) {
  // Helper to determine if an array only contains primitives
  const isFlatArray = (arr) => {
    return arr.every(item => 
      typeof item !== 'object' || item === null
    );
  };

  function format(curr, level, flatten = false) {
    const currentIndent = ' '.repeat(level * indent);
    const nextIndent = ' '.repeat((level + 1) * indent);

    if (Array.isArray(curr)) {
      // Case 1: Array of primitives -> Single line: [1, 2, 3]
      if (isFlatArray(curr)) {
        // JSON.stringify gives [1,2,3], we add spaces after commas for readability
        return JSON.stringify(curr).replace(/,/g, ', ');
      }
      
      // Case 2: Array of Objects/Arrays -> Standard multiline formatting
      const items = curr.map(v => format(v, level + 1, flatten));
      return `[\n${nextIndent}${items.join(`,\n${nextIndent}`)}\n${currentIndent}]`;
    }
    
    if (typeof curr === 'object' && curr !== null) {
      const keys = Object.keys(curr);
      if (keys.length === 0) return '{}';
      
      const items = keys.map(key => {
        let nextFlatten = false;
        nextFlatten |= key === "componentMix";
        nextFlatten |= key === "controlPoints";
        nextFlatten |= key === "red";
        nextFlatten |= key === "green";
        nextFlatten |= key === "blue";
        nextFlatten |= key === "white";
        const val = format(curr[key], level + 1, nextFlatten);
        // Ensure keys are quoted strings
        return `"${key}": ${val}`;
      });
      if (flatten) {
        return `{ ${items.join(`, `)} }`;
      } else {
        return `{\n${nextIndent}${items.join(`,\n${nextIndent}`)}\n${currentIndent}}`;
      }
    }

    // Primitives (strings, numbers, booleans, null)
    if (typeof(curr) == 'number') {
      return JSON.stringify(Number(Number(curr).toFixed(8)));
    }
    return JSON.stringify(curr);
  }

  return format(data, 0);
}

const kEditingColor = "white";
const kErrorColor = "rgb(255, 200, 200)";
const kPassColor = "rgb(200, 255, 200)";
const kOutdatedColor = "rgb(200, 200, 200)";

let resizeAll = function() {
  Binary.rows = Binary.value.split('\n').length;
  Syntax.rows = Syntax.value.split('\n').length;
  Semantics.rows = Semantics.value.split('\n').length;
}

let onParse = function() {
  Syntax.value = 'error';
  Syntax.style.backgroundColor = kErrorColor;
  try {
    const list = Binary.value.split(',').map(item => Number(item.trim()));
    const binary = new Uint8Array(list);
    let syntax = SmpteSt2094App5.binaryToSyntax(binary);
    Syntax.style.backgroundColor = kPassColor;
    Syntax.value = compactJson(syntax);
    resizeAll();
  } catch (e) {
    throw(e);
  }
};

let onSerialize = function() {
  Binary.value = '';
  Binary.style.backgroundColor = kErrorColor;
  try {
    let syntax = JSON.parse(Syntax.value);
    let binary = SmpteSt2094App5.syntaxToBinary(syntax);
    for (let i = 0; i < binary.length; ++i) {
      Binary.value += '0x' + Number(binary[i]).toString(16).padStart(2, '0') + ', ';
      if ((i + 1) % 8 === 0) {
        Binary.value += '\n';
      }
    }
    Binary.style.backgroundColor = kPassColor;
    resizeAll();
  } catch (e) {
    throw(e);
  }
}

let onToJson = function() {
  Semantics.value = 'error';
  Semantics.style.backgroundColor = kErrorColor;
  try {
    let syntax = JSON.parse(Syntax.value);
    let metadata = SmpteSt2094App5.syntaxToColorVolumeTransform(syntax);
    Semantics.style.backgroundColor = kPassColor;
    Semantics.value = compactJson(metadata);
    resizeAll();
  } catch (e) {
    throw(e);
  }
}

let onBinaryChanged = function() {
  Binary.style.backgroundColor = kEditingColor;
  Syntax.style.backgroundColor = kOutdatedColor;
  Semantics.style.backgroundColor = kOutdatedColor;
  resizeAll();
}

let onSyntaxChanged = function() {
  Binary.style.backgroundColor = kOutdatedColor;
  Syntax.style.backgroundColor = kEditingColor;
  Semantics.style.backgroundColor = kOutdatedColor;
  resizeAll();
}

let main = function() {
  resizeAll();
}

</script>
</head>
<body onload="main();">

<h2>Binary</h2>
<p>Comma separated list of hex values, as of the form output by <code>xxd -i</code>.</p>
<p>
<textarea id="Binary" rows=10, cols=120 oninput="onBinaryChanged();">
  0x00, 0xc0, 0x07, 0xd0, 0x4e, 0x20, 0x44, 0x00, 0x00, 0xc6, 0x92, 0x7c,
  0x30, 0xd4, 0x00, 0x00, 0x00, 0x27, 0x10, 0x46, 0x50, 0x27, 0x10, 0x00,
  0x18, 0x00, 0x00, 0x03, 0xe8, 0x07, 0xd0, 0x0b, 0xb8, 0x27, 0x10, 0x13,
  0x88, 0x0f, 0xa0, 0x0b, 0xb8, 0x46, 0x50, 0x4a, 0xc6, 0x4f, 0x26, 0x53,
  0x5c, 0x75, 0x30, 0x40, 0x08, 0x00, 0x00, 0x03, 0xe8, 0x27, 0x10, 0x13,
  0x88, 0x46, 0x50, 0x4a, 0xc6, 0x9c, 0x40, 0xf8, 0x3a, 0x98, 0x75, 0x30,
  0x13, 0x88, 0x18, 0x00, 0x00, 0x03, 0xe8, 0x07, 0xd0, 0x07, 0xd0, 0x27,
  0x10, 0x13, 0x88, 0x0f, 0xa0, 0x0f, 0xa0, 0x46, 0x50, 0x4a, 0xc6, 0x5b,
  0x11, 0x61, 0xa6,"
</textarea>
</p>
<p>
  <button id="Parse" onclick="onParse();">Parse</button>
</p>
</input>

<h2>Syntax:</h2>
<p>
  <button id="Serialize" onclick="onSerialize();">Serialize</button>
</p>
<textarea id="Syntax" oninput = "onSyntaxChanged();"></textarea>
<p>
  <button id="ToJson" onclick="onToJson();">To JSON</button>
</p>

<h2>Semantics (JSON representation of Color Volume Transform):</h2>
<p>
  <button id="FromJson" onclick="onFromJson();" disabled>From JSON</button>
</p>
<textarea id="Semantics"></textarea>
</body>
